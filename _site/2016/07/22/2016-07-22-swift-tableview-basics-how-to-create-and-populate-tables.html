<p>Tutorial from: https://www.weheartswift.com/how-to-make-a-simple-table-view-with-ios-8-and-swift/</p>

<p>Create a table view property
@IBOutlet weak var tableView: UITableView! // Connect to the storyboard element</p>

<p>Initialize the class
class ViewController: UIViewController, UITableViewDelegate, UITableViewDataSource { … }
Connect the class to the storyboard</p>

<p>Setup different UITableView properties
// Imperative
func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {
        return 0
    }</p>

<p>// Imperative
    func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell {
        return UITableViewCell()
    }</p>

<div class="highlighter-rouge"><pre class="highlight"><code>func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) {
}
</code></pre>
</div>

<p>Register Cell Class
In the view controller/tableviewdelegate/datasource class, you must register the class for the table view:
override func viewDidLoad() {
    super.viewDidLoad()</p>

<div class="highlighter-rouge"><pre class="highlight"><code>self.tableView.registerClass(UITableViewCell.self, forCellReuseIdentifier: "cell") //    tableView.setup(scrollable: false) // Turn off scrolling
</code></pre>
</div>

<p>}</p>

<p>Adding Data to Display
First step is to declare the data. In this case we’re going to use dummy data:
var items: [String] = [“Hello”, “World”, “Swift”]</p>

<p>Using this data, we can now set the number of rows in our table view by calling the function:
func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {
    return items.count
}</p>

<p>Create the cell.
func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell {
    var cell:UITableViewCell = self.tableView.dequeueReusableCellWithIdentifier(“cell”) as UITableViewCell</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cell.textLabel?.text = self.items[indexPath.row]

return cell }
</code></pre>
</div>

<p>Handling cell selection:
func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) {
    println(“You selected cell #(indexPath.row)!”)
}</p>

<p>Final code should look like this:
class ViewController: UIViewController, UITableViewDelegate, UITableViewDataSource {
    @IBOutlet
    var tableView: UITableView
    var items: [String] = [“We”, “Heart”, “Swift”]</p>

<div class="highlighter-rouge"><pre class="highlight"><code>override func viewDidLoad() {
    super.viewDidLoad()

    self.tableView.registerClass(UITableViewCell.self, forCellReuseIdentifier: "cell")
}


func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {
    return self.items.count;
}

func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell {
    var cell:UITableViewCell = self.tableView.dequeueReusableCellWithIdentifier("cell") as UITableViewCell

    cell.textLabel?.text = self.items[indexPath.row]

    return cell
}

func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) {
    println("You selected cell #\(indexPath.row)!")
} }
</code></pre>
</div>

<p>To create a custom cell with more than just a single label, follow these steps:</p>

<p>Drag a Table View Cell onto your UITableView. This will automatically generate a cell labeled “Prototype” that contains a nested content view. Treat this content view as any other view and drag UI elements like text fields, images, etc. onto the content view.</p>

<p>Now, create a new Swift file for the UITableViewCell class to connect your Table View Cell to some code. Initialize the class like so:
class StepsCell: UITableViewCell {
    // IB Outlets go here:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>override func awakeFromNib() {
    super.awakeFromNib()
    // Initialization code
}

override func setSelected(selected: Bool, animated: Bool) {
    super.setSelected(selected, animated: animated)

    // Configure the view for the selected state
} }
</code></pre>
</div>

<p>Hook up the UI elements in the content view with IBOutlets in your UITableViewCell class. It’s identical to how you would do this for any other view controller. You can add constraints, stack views, etc. Just treat the content view as you would a blank view controller.</p>

<p>Now to access those UI elements in your main Table View Controller, you must use the “dequeueReusableCellWithIdentifier” command. Dequeue basically describes the manner in which data loads and unloads. If you imagine the scrolling items as a wheel, as the topmost item disappears, it reappears on the bottom. The table view is endlessly recycling the same x number of cells. This is a good approach for memory management especially when dealing with 100+ cells. Once you’ve stored the cell, you can then modify the various UI elements and return the cell to populate the table view.</p>

<p>func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell {
    var cell = self.tableView.dequeueReusableCellWithIdentifier(“StepsCell”)! as! StepsCell // Same identifier as class name
    cell.dateLabel.text = “January (indexPath)”
    cell.textLabel?.text = String(indexPath)
    return cell
}</p>

<p>For populating table views with data from asynchronous requests, it can be helpful to reload your table view once you know all your data is complete
// Reload in main queue
dispatch_async(dispatch_get_main_queue(), { () -&gt; Void in
    self.tableView.reloadData() // Reload
})</p>
